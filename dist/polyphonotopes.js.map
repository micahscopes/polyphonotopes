{"version":3,"file":"polyphonotopes.js","sources":["../node_modules/graph-hops/dist/graph-hops.mjs","../index.js"],"sourcesContent":["var classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n/** Calculator for finding widest and/or shortest paths in a graph using the Floyed-Warshall algorithm. */\n\nvar FloydWarshall = function () {\n\n  /**\n   * Create a Floyd-Warshall calculator for a specific adjacency matrix.\n   * @param {number[][]} adjacencyMatrix - A square matrix representing a graph with weighted edges.\n   */\n  function FloydWarshall(adjacencyMatrix) {\n    classCallCheck(this, FloydWarshall);\n\n    this.adjacencyMatrix = adjacencyMatrix;\n  }\n\n  /**\n   * Calculates the widest distance from one node to the other.\n   * @return {number[][]} - Matrix with distances from a node to the other\n   */\n\n\n  createClass(FloydWarshall, [{\n    key: '_initializeDistanceMatrix',\n\n\n    /**\n     * @private\n     */\n    value: function _initializeDistanceMatrix(blankFiller) {\n      var distMatrix = [];\n      for (var i = 0; i < this.order; ++i) {\n        distMatrix[i] = [];\n        for (var j = 0; j < this.order; ++j) {\n          if (i === j) {\n            distMatrix[i][j] = 0;\n          } else {\n            var val = this.adjacencyMatrix[i][j];\n            if (val) {\n              distMatrix[i][j] = val;\n            } else {\n              distMatrix[i][j] = blankFiller;\n            }\n          }\n        }\n      }\n      return distMatrix;\n    }\n  }, {\n    key: 'widestPaths',\n    get: function get$$1() {\n      var distMatrix = this._initializeDistanceMatrix(0);\n      for (var k = 0; k < this.order; ++k) {\n        for (var i = 0; i < this.order; ++i) {\n          if (i === k) {\n            continue;\n          }\n          for (var j = 0; j < this.order; ++j) {\n            if (j === i || j === k) {\n              continue;\n            }\n            var direct = distMatrix[i][j];\n            var detour = Math.min(distMatrix[i][k], distMatrix[k][j]);\n            if (detour > direct) {\n              distMatrix[i][j] = detour;\n            }\n          }\n        }\n      }\n      return distMatrix;\n    }\n\n    /**\n     * Calculates the shortest paths of the weighted graph.\n     * (The output will not be accurate if the graph has a negative cycle.)\n     * @return {number[][]} - Matrix with distances from a node to the other\n     */\n\n  }, {\n    key: 'shortestPaths',\n    get: function get$$1() {\n      var distMatrix = this._initializeDistanceMatrix(Infinity);\n\n      for (var k = 0; k < this.order; ++k) {\n        for (var i = 0; i < this.order; ++i) {\n          for (var j = 0; j < this.order; ++j) {\n            var dist = distMatrix[i][k] + distMatrix[k][j];\n            if (distMatrix[i][j] > dist) {\n              distMatrix[i][j] = dist;\n            }\n          }\n        }\n      }\n\n      for (var _i = 0; _i < this.order; ++_i) {\n        for (var _j = 0; _j < this.order; ++_j) {\n          if (distMatrix[_i][_j] === Infinity) {\n            distMatrix[_i][_j] = -1;\n          }\n        }\n      }\n\n      return distMatrix;\n    }\n\n    /**\n     * Get the order of the adjacency matrix (and of the output distance matrices.)\n     * @return {integer} The order of the adjacency matrix.\n     */\n\n  }, {\n    key: 'order',\n    get: function get$$1() {\n      return this.adjacencyMatrix.length;\n    }\n  }]);\n  return FloydWarshall;\n}();\n\nvar index = FloydWarshall;\n\nfunction unweightedAdjacencyMatrix(nodes, edges, id) {\n  if (!id) {\n    id = function id(obj) {\n      return obj;\n    };\n  }\n  if (nodes.length < 2) {\n    return [];\n  }\n  var adj = [];\n  for (var i = 0; i < nodes.length; i++) {\n    adj[i] = new Array(nodes.length);\n  }\n\n  edges.forEach(function (edge) {\n    adj[nodes.indexOf(nodes.find(function (o) {\n      return id(o) == edge.source;\n    }))][nodes.indexOf(nodes.find(function (o) {\n      return id(o) == edge.target;\n    }))] = 1;\n  });\n  return adj;\n}\n\nfunction graphHops(nodes, edges, id, proto) {\n  var adj = unweightedAdjacencyMatrix(nodes, edges, id);\n  var hopMatrix = new index(adj).shortestPaths;\n  var hops = { 1: edges };\n  hopMatrix.forEach(function (row, i) {\n    row.forEach(function (hop, j) {\n      if (hop > 1) {\n        if (!hops[hop]) {\n          hops[hop] = [];\n        }\n        var h = {};\n        if (proto) proto(h);\n        h.source = nodes[i];h.target = nodes[j];\n        hops[hop].push(h);\n      }\n    });\n  });\n  return hops;\n}\n\nexport { unweightedAdjacencyMatrix, graphHops };\n//# sourceMappingURL=graph-hops.mjs.map\n","import ghops from 'graph-hops'\nconst Bitset = require('fast-bitset')\nconst minrepr = require('min-repr')\n\nexport function accidentals(size) {\n    let acc = new Bitset(size)\n    acc.set(0)\n    acc.set(1)\n    \n    let accidentals = []\n    for (let i=0; i<size; i++) {\n        accidentals.push(acc)\n        acc = acc.circularShift(1)\n    }\n\n    return accidentals;\n}\nexport function intervals(bs){\n    let r = []\n    let indices = bs.getIndices()\n    let size = indices.length\n    for(let i=0; i<size; i++){\n        r.push(indices[(i+1)%size] + (i+1 >= size ? bs.MAX_BIT+1 : 0) - indices[i])\n    }\n    return r;\n}\n\nexport function shape(bs){\n    let intershape = intervals(bs)\n    let shift = minrepr(intershape)\n    let size = intershape.length\n    let shape = []\n    for(let i=shift; i<size+shift; i++){\n        shape.push(intershape[i%size])\n    }\n    return String(shape)\n}\n\n\nexport function findShapes(shapes,visit){\n    if(shapes.constructor === Bitset){shapes = [shapes]}\n    if(visit && visit.constructor === Bitset){visit = [visit]}\n    let size = shapes[0].MAX_BIT+1\n    visit = visit ? visit : shapes\n    shapes = shapes.map((s) => shape(s))\n    let lookingFor = (g) => shapes.includes(shape(g))\n    return explore(visit,lookingFor)\n}\nexport function explore(visit,lookingFor){\n    lookingFor = lookingFor ? lookingFor : (g)=>true\n    if(visit && visit.constructor === Bitset){visit = [visit]}\n    let size = visit[0].MAX_BIT+1\n\n    let visited = []\n    let keepers = []\n\n    let Acc = accidentals(size)\n    while(visit.length > 0) {\n        let start = visit.pop()\n        if (visited.includes(start.dehydrate())) { continue }\n        visited.push(start.dehydrate())\n        let goto = Acc.map((a)=>start.xor(a))\n        for(let g of goto){\n            if(lookingFor(g)){\n                keepers.push([start,g])\n                if(!visited.includes(g.dehydrate())){\n                    visit.push(g)\n                }\n            }\n        }\n    }\n    return keepers\n}\n\n\n// was gonna make an algorithm that accumulates a\n// running smallest shape but then i found the \n// min-repr library and decided not to.\n//export function shape(set){\n//    let size = set.MAX_BIT+1\n//    let indices = set.getIndices()\n//    let sh = []\n//    let shift = 0;\n//    while( sh.length < set.getIndices().length ) {\n//        for(let k=0; k<sh.length; k++){\n//            let next = indices[(shift+k)%size]\n//            if(next > sh[k]) {\n//                shift += k\n//                sh = []\n//            } else {\n//                sh.push(next)\n//            }\n//        }\n//    }\n//}\n\n"],"names":["classCallCheck","instance","Constructor","TypeError","createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","defineProperty","key","protoProps","staticProps","prototype","FloydWarshall","adjacencyMatrix","_initializeDistanceMatrix","blankFiller","distMatrix","order","j","val","get$$1","k","direct","detour","Math","min","Infinity","dist","_i","_j","Bitset","require","minrepr","accidentals","size","acc","set","push","circularShift","intervals","bs","r","indices","getIndices","MAX_BIT","shape","intershape","shift","String","findShapes","shapes","visit","constructor","map","s","lookingFor","g","includes","explore","visited","keepers","Acc","start","pop","dehydrate","goto","a","xor"],"mappings":"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"}