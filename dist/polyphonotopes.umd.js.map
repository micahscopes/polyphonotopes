{"version":3,"file":"polyphonotopes.umd.js","sources":["../node_modules/graph-hops/dist/graph-hops.mjs","../node_modules/fast-bitset/app/BitSet.js","../node_modules/min-repr/min-repr.js","../index.js"],"sourcesContent":["var classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n/** Calculator for finding widest and/or shortest paths in a graph using the Floyed-Warshall algorithm. */\n\nvar FloydWarshall = function () {\n\n  /**\n   * Create a Floyd-Warshall calculator for a specific adjacency matrix.\n   * @param {number[][]} adjacencyMatrix - A square matrix representing a graph with weighted edges.\n   */\n  function FloydWarshall(adjacencyMatrix) {\n    classCallCheck(this, FloydWarshall);\n\n    this.adjacencyMatrix = adjacencyMatrix;\n  }\n\n  /**\n   * Calculates the widest distance from one node to the other.\n   * @return {number[][]} - Matrix with distances from a node to the other\n   */\n\n\n  createClass(FloydWarshall, [{\n    key: '_initializeDistanceMatrix',\n\n\n    /**\n     * @private\n     */\n    value: function _initializeDistanceMatrix(blankFiller) {\n      var distMatrix = [];\n      for (var i = 0; i < this.order; ++i) {\n        distMatrix[i] = [];\n        for (var j = 0; j < this.order; ++j) {\n          if (i === j) {\n            distMatrix[i][j] = 0;\n          } else {\n            var val = this.adjacencyMatrix[i][j];\n            if (val) {\n              distMatrix[i][j] = val;\n            } else {\n              distMatrix[i][j] = blankFiller;\n            }\n          }\n        }\n      }\n      return distMatrix;\n    }\n  }, {\n    key: 'widestPaths',\n    get: function get$$1() {\n      var distMatrix = this._initializeDistanceMatrix(0);\n      for (var k = 0; k < this.order; ++k) {\n        for (var i = 0; i < this.order; ++i) {\n          if (i === k) {\n            continue;\n          }\n          for (var j = 0; j < this.order; ++j) {\n            if (j === i || j === k) {\n              continue;\n            }\n            var direct = distMatrix[i][j];\n            var detour = Math.min(distMatrix[i][k], distMatrix[k][j]);\n            if (detour > direct) {\n              distMatrix[i][j] = detour;\n            }\n          }\n        }\n      }\n      return distMatrix;\n    }\n\n    /**\n     * Calculates the shortest paths of the weighted graph.\n     * (The output will not be accurate if the graph has a negative cycle.)\n     * @return {number[][]} - Matrix with distances from a node to the other\n     */\n\n  }, {\n    key: 'shortestPaths',\n    get: function get$$1() {\n      var distMatrix = this._initializeDistanceMatrix(Infinity);\n\n      for (var k = 0; k < this.order; ++k) {\n        for (var i = 0; i < this.order; ++i) {\n          for (var j = 0; j < this.order; ++j) {\n            var dist = distMatrix[i][k] + distMatrix[k][j];\n            if (distMatrix[i][j] > dist) {\n              distMatrix[i][j] = dist;\n            }\n          }\n        }\n      }\n\n      for (var _i = 0; _i < this.order; ++_i) {\n        for (var _j = 0; _j < this.order; ++_j) {\n          if (distMatrix[_i][_j] === Infinity) {\n            distMatrix[_i][_j] = -1;\n          }\n        }\n      }\n\n      return distMatrix;\n    }\n\n    /**\n     * Get the order of the adjacency matrix (and of the output distance matrices.)\n     * @return {integer} The order of the adjacency matrix.\n     */\n\n  }, {\n    key: 'order',\n    get: function get$$1() {\n      return this.adjacencyMatrix.length;\n    }\n  }]);\n  return FloydWarshall;\n}();\n\nvar index = FloydWarshall;\n\nfunction unweightedAdjacencyMatrix(nodes, edges, id) {\n  if (!id) {\n    id = function id(obj) {\n      return obj;\n    };\n  }\n  if (nodes.length < 2) {\n    return [];\n  }\n  var adj = [];\n  for (var i = 0; i < nodes.length; i++) {\n    adj[i] = new Array(nodes.length);\n  }\n\n  edges.forEach(function (edge) {\n    adj[nodes.indexOf(nodes.find(function (o) {\n      return id(o) == edge.source;\n    }))][nodes.indexOf(nodes.find(function (o) {\n      return id(o) == edge.target;\n    }))] = 1;\n  });\n  return adj;\n}\n\nfunction graphHops(nodes, edges, id, proto) {\n  var adj = unweightedAdjacencyMatrix(nodes, edges, id);\n  var hopMatrix = new index(adj).shortestPaths;\n  var hops = { 1: edges };\n  hopMatrix.forEach(function (row, i) {\n    row.forEach(function (hop, j) {\n      if (hop > 1) {\n        if (!hops[hop]) {\n          hops[hop] = [];\n        }\n        var h = {};\n        if (proto) proto(h);\n        h.source = nodes[i];h.target = nodes[j];\n        hops[hop].push(h);\n      }\n    });\n  });\n  return hops;\n}\n\nexport { unweightedAdjacencyMatrix, graphHops };\n//# sourceMappingURL=graph-hops.mjs.map\n","//Matt Krick, matt.krick@gmail.com, MIT License\n\n//each bin holds bits 0 - 30, totaling 31 (sign takes up last bit)\nvar BITS_PER_INT = 31;\n//used for ffs of a word in O(1) time. LUTs get a bad wrap, they are fast.\nvar multiplyDeBruijnBitPosition = [0, 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4, 8,\n  31, 27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9];\n\n/**\n *\n * Create a new bitset. Accepts either the maximum number of bits, or a dehydrated bitset\n * @param {number|string} nBitsOrKey - Number of bits in the set or dehydrated bitset.\n * For speed and space concerns, the initial number of bits cannot be increased.\n * @constructor\n */\nvar BitSet = function (nBitsOrKey) {\n  var wordCount, arrVals, front, leadingZeros, i;\n  if (typeof nBitsOrKey === 'number') {\n    nBitsOrKey = nBitsOrKey || BITS_PER_INT; //default to 1 word\n    wordCount = Math.ceil(nBitsOrKey / BITS_PER_INT);\n    this.arr = new Uint32Array(wordCount);\n    this.MAX_BIT = nBitsOrKey - 1;\n  } else {\n    arrVals = JSON.parse(\"[\" + nBitsOrKey + \"]\");\n    this.MAX_BIT = arrVals.pop();\n    leadingZeros = arrVals.pop();\n    if (leadingZeros > 0) {\n      front = [];\n      for (i = 0; i < leadingZeros; i++) front[i] = 0;\n      for (i = 0; i < arrVals.length; i++) front[leadingZeros + i] = arrVals[i];\n      arrVals = front;\n    }\n    wordCount = Math.ceil((this.MAX_BIT + 1) / BITS_PER_INT);\n    this.arr = new Uint32Array(wordCount)\n    this.arr.set(arrVals);\n  }\n};\n\n/**\n * Check whether a bit at a specific index is set\n * @param {number} idx the position of a single bit to check\n * @returns {boolean} true if bit is set, else false\n */\nBitSet.prototype.get = function (idx) {\n  var word = this._getWord(idx);\n  return (word === -1) ? false : (((this.arr[word] >> (idx % BITS_PER_INT)) & 1) === 1);\n};\n\n/**\n * Set a single bit\n * @param {number} idx the position of a single bit to set\n * @returns {boolean} true if set was successful, else false\n */\nBitSet.prototype.set = function (idx) {\n  var word = this._getWord(idx);\n  if (word === -1) return false;\n  this.arr[word] |= 1 << (idx % BITS_PER_INT);\n  return true;\n};\n\n/**\n * Set a range of bits\n * @param {number} from the starting index of the range to set\n * @param {number} to the ending index of the range to set\n * @returns {boolean} true if set was successful, else false\n */\nBitSet.prototype.setRange = function (from, to) {\n  return this._doRange(from, to, _setFunc);\n};\n\n/**\n * Unset a single bit\n * @param {number} idx the position of a single bit to unset\n * @returns {boolean} true if set was successful, else false\n */\nBitSet.prototype.unset = function (idx) {\n  var word = this._getWord(idx);\n  if (word === -1) return false;\n  this.arr[word] &= ~(1 << (idx % BITS_PER_INT));\n  return true;\n};\n\n/**\n * Unset a range of bits\n * @param {number} from the starting index of the range to unset\n * @param {number} to the ending index of the range to unset\n * @returns {boolean} true if set was successful, else false\n */\nBitSet.prototype.unsetRange = function (from, to) {\n  return this._doRange(from, to, _unsetFunc);\n};\n\n/**\n * Toggle a single bit\n * @param {number} idx the position of a single bit to toggle\n * @returns {boolean} true if set was successful, else false\n */\nBitSet.prototype.toggle = function (idx) {\n  var word = this._getWord(idx);\n  if (word === -1) return false;\n  this.arr[word] ^= (1 << (idx % BITS_PER_INT));\n  return true;\n};\n\n/**\n * Toggle a range of bits\n * @param {number} from the starting index of the range to toggle\n * @param {number} to the ending index of the range to toggle\n * @returns {boolean} true if set was successful, else false\n */\nBitSet.prototype.toggleRange = function (from, to) {\n  return this._doRange(from, to, _toggleFunc);\n};\n\n/**\n *\n * Clear an entire bitset\n * @returns {boolean} true\n */\nBitSet.prototype.clear = function () {\n  for (var i = 0; i < this.arr.length; i++) {\n    this.arr[i] = 0;\n  }\n  return true;\n};\n\n/**\n * Clone a bitset\n * @returns {BitSet} an copy (by value) of the calling bitset\n */\nBitSet.prototype.clone = function () {\n  return new BitSet(this.dehydrate());\n};\n\n/**\n *\n * Turn the bitset into a comma separated string that skips leading & trailing 0 words.\n * Ends with the number of leading 0s and MAX_BIT.\n * Useful if you need the bitset to be an object key (eg dynamic programming).\n * Can rehydrate by passing the result into the constructor\n * @returns {string} representation of the bitset\n */\nBitSet.prototype.dehydrate = function () {\n  var i, lastUsedWord, s;\n  var leadingZeros = 0;\n  for (i = 0; i < this.arr.length; i++) {\n    if (this.arr[i] !== 0) break;\n    leadingZeros++;\n  }\n  for (i = this.arr.length - 1; i >= leadingZeros; i--) {\n    if (this.arr[i] !== 0) {\n      lastUsedWord = i;\n      break;\n    }\n  }\n  s = '';\n  for (i = leadingZeros; i <= lastUsedWord; i++) {\n    s += (this.arr[i] + ',');\n  }\n  s += (leadingZeros + ',' + this.MAX_BIT); //leading 0s, stop numbers\n  return s;\n};\n\n/**\n *\n * Perform a bitwise AND on 2 bitsets or 1 bitset and 1 index.\n * Both bitsets must have the same number of words, no length check is performed to prevent and overflow.\n * @param {BitSet | Number} bsOrIdx a bitset or single index to check (useful for LP, DP problems)\n * @returns {BitSet} a new bitset that is the bitwise AND of the two\n */\nBitSet.prototype.and = function (bsOrIdx) {\n  return this._op(bsOrIdx, _and);\n};\n\n/**\n *\n * Perform a bitwise OR on 2 bitsets or 1 bitset and 1 index.\n * Both bitsets must have the same number of words, no length check is performed to prevent and overflow.\n * @param {BitSet | Number} bsOrIdx a bitset or single index to check (useful for LP, DP problems)\n * @returns {BitSet} a new bitset that is the bitwise OR of the two\n */\nBitSet.prototype.or = function (bsOrIdx) {\n  return this._op(bsOrIdx, _or);\n};\n\n/**\n *\n * Perform a bitwise XOR on 2 bitsets or 1 bitset and 1 index.\n * Both bitsets must have the same number of words, no length check is performed to prevent and overflow.\n * @param {BitSet | Number} bsOrIdx a bitset or single index to check (useful for LP, DP problems)\n * @returns {BitSet} a new bitset that is the bitwise XOR of the two\n */\nBitSet.prototype.xor = function (bsOrIdx) {\n  return this._op(bsOrIdx, _xor);\n};\n\n/**\n * Run a custom function on every set bit. Faster than iterating over the entire bitset with a `get()`\n * Source code includes a nice pattern to follow if you need to break the for-loop early\n * @param {Function} func the function to pass the next set bit to\n */\nBitSet.prototype.forEach = function (func) {\n  for (var i = this.ffs(); i !== -1; i = this.nextSetBit(i + 1)) {\n    func(i);\n  }\n};\n\n/**\n * Circular shift bitset by an offset\n * @param {Number} number of positions that the bitset that will be shifted to the right.\n * Using a negative number will result in a left shift.\n * @returns {Bitset} a new bitset that is rotated by the offset\n */\n\nBitSet.prototype.circularShift = function(offset) {\n  offset = -offset;\n\n  var S = this; // source BitSet (this)\n  var MASK_SIGN = 0x7fffffff;\n  var BITS = S.MAX_BIT+1;\n  var WORDS = S.arr.length;\n  var BITS_LAST_WORD = BITS_PER_INT - (WORDS*BITS_PER_INT - BITS);\n\n  var T = new BitSet(BITS); // target BitSet (the shifted bitset)\n\n  var s; var t = 0; // (s)ource and (t)arget word indices\n  var i; var j = 0; // current bit indices for source (i) and target (j) words\n  var z = 0; // bit index for entire sequence.\n\n  offset = (BITS + (offset % BITS)) % BITS // positive, within length\n  var s = ~~(offset / BITS_PER_INT) % WORDS\n  var i = offset % BITS_PER_INT\n  while (z < BITS){\n    var sourceWordLength = s === WORDS - 1 ? BITS_LAST_WORD : BITS_PER_INT\n    var bits = S.arr[s]\n\n    if (i > 0) {\n      bits = bits >>> i;\n    }\n    if (j > 0) {\n      bits = bits << j;\n    }\n\n    T.arr[t] = T.arr[t] | bits\n\n    var bitsAdded = Math.min(BITS_PER_INT-j,sourceWordLength - i);\n    z += bitsAdded;\n    j += bitsAdded;\n    if(j >= BITS_PER_INT){\n      T.arr[t] = T.arr[t] & MASK_SIGN\n      j = 0; t++;\n    }\n    i += bitsAdded;\n    if(i >= sourceWordLength){ i = 0; s++;}\n    if(s >= WORDS){ s -= WORDS;}\n  }\n  T.arr[WORDS-1] = T.arr[WORDS-1] & (MASK_SIGN >>> (BITS_PER_INT-BITS_LAST_WORD));\n  return T;\n};\n\n/**\n * Get the cardinality (count of set bits) for the entire bitset\n * @returns {number} cardinality\n */\nBitSet.prototype.getCardinality = function () {\n  var setCount = 0;\n  for (var i = this.arr.length - 1; i >= 0; i--) {\n    var j = this.arr[i];\n    j = j - ((j >> 1) & 0x55555555);\n    j = (j & 0x33333333) + ((j >> 2) & 0x33333333);\n    setCount += ((((j + (j >> 4)) & 0x0F0F0F0F) * 0x01010101) >> 24);\n  }\n  return setCount;\n};\n\n/**\n * Get the indices of all set bits. Useful for debugging, uses `forEach` internally\n * @returns {Array} Indices of all set bits\n */\nBitSet.prototype.getIndices = function () {\n  var indices = [];\n  this.forEach(function (i) {\n    indices.push(i);\n  });\n  return indices;\n};\n\n/**\n * Checks if one bitset is subset of another. Same thing can be done using _and_ operation and equality check,\n * but then new BitSet would be created, and if one is only interested in yes/no information it would be a waste of memory\n * and additional GC strain.\n * @param {BitSet} bs a bitset to check\n * @returns {Boolean} `true` if provided bitset is a subset of this bitset, `false` otherwise\n */\nBitSet.prototype.isSubsetOf = function (bs) {\n  var arr1 = this.arr;\n  var arr2 = bs.arr;\n  var len = arr1.length;\n  for (var i = 0; i < len; i++) {\n    if ((arr1[i] & arr2[i]) !== arr1[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Quickly determine if a bitset is empty\n * @returns {boolean} true if the entire bitset is empty, else false\n */\nBitSet.prototype.isEmpty = function () {\n  var i, arr;\n  arr = this.arr;\n  for (i = 0; i < arr.length; i++) {\n    if (arr[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n *\n * Quickly determine if both bitsets are equal (faster than checking if the XOR of the two is === 0).\n * Both bitsets must have the same number of words, no length check is performed to prevent and overflow.\n * @param {BitSet} bs\n * @returns {boolean} true if the entire bitset is empty, else false\n */\nBitSet.prototype.isEqual = function (bs) {\n  var i;\n  for (i = 0; i < this.arr.length; i++) {\n    if (this.arr[i] !== bs.arr[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Get a string representation of the entire bitset, including leading 0s (useful for debugging)\n * @returns {string} a base 2 representation of the entire bitset\n */\nBitSet.prototype.toString = function () {\n  var i, str, fullString = '';\n  for (i = this.arr.length - 1; i >= 0; i--) {\n    str = this.arr[i].toString(2);\n    fullString += ('0000000000000000000000000000000' + str).slice(-BITS_PER_INT);\n  }\n  return fullString;\n};\n\n/**\n * Find first set bit (useful for processing queues, breadth-first tree searches, etc.)\n * @param {number} _startWord the word to start with (only used internally by nextSetBit)\n * @returns {number} the index of the first set bit in the bitset, or -1 if not found\n */\nBitSet.prototype.ffs = function (_startWord) {\n  var setVal, i, fs = -1;\n  _startWord = _startWord || 0;\n  for (i = _startWord; i < this.arr.length; i++) {\n    setVal = this.arr[i];\n    if (setVal === 0) continue;\n    fs = _lsb(setVal) + i * BITS_PER_INT;\n    break;\n  }\n  return fs <= this.MAX_BIT ? fs : -1;\n};\n\n/**\n * Find first zero (unset bit)\n * @param {number} _startWord the word to start with (only used internally by nextUnsetBit)\n * @returns {number} the index of the first unset bit in the bitset, or -1 if not found\n */\nBitSet.prototype.ffz = function (_startWord) {\n  var i, setVal, fz = -1;\n  _startWord = _startWord || 0;\n  for (i = _startWord; i < this.arr.length; i++) {\n    setVal = this.arr[i];\n    if (setVal === 0x7fffffff) continue;\n    setVal ^= 0x7fffffff;\n    fz = _lsb(setVal) + i * BITS_PER_INT;\n    break;\n  }\n  return fz <= this.MAX_BIT ? fz : -1;\n};\n\n/**\n *\n * Find last set bit\n * @param {number} _startWord the word to start with (only used internally by previousSetBit)\n * @returns {number} the index of the last set bit in the bitset, or -1 if not found\n */\nBitSet.prototype.fls = function (_startWord) {\n  var i, setVal, ls = -1;\n  if (_startWord === undefined) _startWord = this.arr.length - 1;\n  for (i = _startWord; i >= 0; i--) {\n    setVal = this.arr[i];\n    if (setVal === 0) continue;\n    ls = _msb(setVal) + i * BITS_PER_INT;\n    break;\n  }\n  return ls;\n};\n\n/**\n *\n * Find last zero (unset bit)\n * @param {number} _startWord the word to start with (only used internally by previousUnsetBit)\n * @returns {number} the index of the last unset bit in the bitset, or -1 if not found\n */\nBitSet.prototype.flz = function (_startWord) {\n  var i, setVal, ls = -1;\n  if (_startWord === undefined) _startWord = this.arr.length - 1;\n  for (i = _startWord; i >= 0; i--) {\n    setVal = this.arr[i];\n    if (i === this.arr.length - 1) {\n      var wordIdx = this.MAX_BIT % BITS_PER_INT;\n      var unusedBitCount = BITS_PER_INT - wordIdx - 1;\n      setVal |= ((1 << unusedBitCount) - 1) << (wordIdx + 1);\n    }\n    if (setVal === 0x7fffffff) continue;\n    setVal ^= 0x7fffffff;\n    ls = _msb(setVal) + i * BITS_PER_INT;\n    break;\n  }\n  return ls;\n};\n\n/**\n * Find first set bit, starting at a given index\n * @param {number} idx the starting index for the next set bit\n * @returns {number} the index of the next set bit >= idx, or -1 if not found\n */\nBitSet.prototype.nextSetBit = function (idx) {\n  var startWord = this._getWord(idx);\n  if (startWord === -1) return -1;\n  var wordIdx = idx % BITS_PER_INT;\n  var len = BITS_PER_INT - wordIdx;\n  var mask = ((1 << (len)) - 1) << wordIdx;\n  var reducedWord = this.arr[startWord] & mask;\n  if (reducedWord > 0) {\n    return _lsb(reducedWord) + startWord * BITS_PER_INT;\n  }\n  return this.ffs(startWord + 1);\n};\n\n/**\n * Find first unset bit, starting at a given index\n * @param {number} idx the starting index for the next unset bit\n * @returns {number} the index of the next unset bit >= idx, or -1 if not found\n */\nBitSet.prototype.nextUnsetBit = function (idx) {\n  var startWord = this._getWord(idx);\n  if (startWord === -1) return -1;\n  var mask = ((1 << (idx % BITS_PER_INT)) - 1);\n  var reducedWord = this.arr[startWord] | mask;\n  if (reducedWord === 0x7fffffff) {\n    return this.ffz(startWord + 1);\n  }\n  return _lsb(0x7fffffff ^ reducedWord) + startWord * BITS_PER_INT;\n};\n\n/**\n * Find last set bit, up to a given index\n * @param {number} idx the starting index for the next unset bit (going in reverse)\n * @returns {number} the index of the next unset bit <= idx, or -1 if not found\n */\nBitSet.prototype.previousSetBit = function (idx) {\n  var startWord = this._getWord(idx);\n  if (startWord === -1) return -1;\n  var mask = 0x7fffffff >>> (BITS_PER_INT - (idx % BITS_PER_INT) - 1);\n  var reducedWord = this.arr[startWord] & mask;\n  if (reducedWord > 0) {\n    return _msb(reducedWord) + startWord * BITS_PER_INT;\n  }\n  return this.fls(startWord - 1);\n};\n\n/**\n * Find last unset bit, up to a given index\n * @param {number} idx the starting index for the next unset bit (going in reverse)\n * @returns {number} the index of the next unset bit <= idx, or -1 if not found\n */\nBitSet.prototype.previousUnsetBit = function (idx) {\n  var startWord = this._getWord(idx);\n  if (startWord === -1) return -1;\n  var wordIdx = idx % BITS_PER_INT;\n  var mask = ((1 << (BITS_PER_INT - wordIdx - 1)) - 1) << wordIdx + 1;\n  var reducedWord = this.arr[startWord] | mask;\n  if (reducedWord === 0x7fffffff) {\n    return this.flz(startWord - 1);\n  }\n  return _msb(0x7fffffff ^ reducedWord) + startWord * BITS_PER_INT;\n};\n\n/**\n *\n * @param {number} idx position of bit in bitset\n * @returns {number} the word where the index is located, or -1 if out of range\n * @private\n */\nBitSet.prototype._getWord = function (idx) {\n  return (idx < 0 || idx > this.MAX_BIT) ? -1 : ~~(idx / BITS_PER_INT);\n};\n\n/**\n * Shared function for setting, unsetting, or toggling a range of bits\n * @param {number} from the starting index of the range to set\n * @param {number} to the ending index of the range to set\n * @param {Function} func function to run (set, unset, or toggle)\n * @returns {boolean} true if set was successful, else false\n * @private\n */\nBitSet.prototype._doRange = function (from, to, func) {\n  var i, curStart, curEnd, len;\n  if (to < from) {\n    to ^= from;\n    from ^= to;\n    to ^= from;\n  }\n  var startWord = this._getWord(from);\n  var endWord = this._getWord(to);\n  if (startWord === -1 || endWord === -1) return false;\n  for (i = startWord; i <= endWord; i++) {\n    curStart = (i === startWord) ? from % BITS_PER_INT : 0;\n    curEnd = (i === endWord) ? to % BITS_PER_INT : BITS_PER_INT - 1;\n    len = curEnd - curStart + 1;\n    this.arr[i] = func(this.arr[i], len, curStart);\n\n  }\n  return true;\n};\n\n/**\n * Both bitsets must have the same number of words, no length check is performed to prevent and overflow.\n * @param {BitSet | Number} bsOrIdx a bitset or single index to check (useful for LP, DP problems)\n * @param {Function} func the operation to perform (and, or, xor)\n * @returns {BitSet} a new bitset that is the bitwise operation of the two\n * @private\n */\nBitSet.prototype._op = function (bsOrIdx, func) {\n  var i, arr1, arr2, len, newBS, word;\n  arr1 = this.arr;\n  if (typeof bsOrIdx === 'number') {\n    word = this._getWord(bsOrIdx);\n    newBS = this.clone();\n    if (word !== -1) newBS.arr[word] = func(arr1[word], 1 << (bsOrIdx % BITS_PER_INT));\n  } else {\n    arr2 = bsOrIdx.arr;\n    len = arr1.length;\n    newBS = new BitSet(this.MAX_BIT + 1);\n    for (i = 0; i < len; i++) {\n      newBS.arr[i] = func(arr1[i], arr2[i]);\n    }\n  }\n  return newBS;\n};\n\n/**\n *\n * Returns the least signifcant bit, or 0 if none set, so a prior check to see if the word > 0 is required\n * @param {number} word the current array\n * @returns {number} the index of the least significant bit in the current array\n * @private\n *\n */\nfunction _lsb(word) {\n  return multiplyDeBruijnBitPosition[(((word & -word) * 0x077CB531)) >>> 27];\n}\n\n/**\n * Returns the least signifcant bit, or 0 if none set, so a prior check to see if the word > 0 is required\n * @param word the current array\n * @returns {number} the index of the most significant bit in the current array\n * @private\n */\nfunction _msb(word) {\n  word |= word >> 1;\n  word |= word >> 2;\n  word |= word >> 4;\n  word |= word >> 8;\n  word |= word >> 16;\n  word = (word >> 1) + 1;\n  return multiplyDeBruijnBitPosition[(word * 0x077CB531) >>> 27];\n}\n\nfunction _toggleFunc(word, len, curStart) {\n  var mask = (((1 << len) - 1) << curStart);\n  return word ^ mask;\n}\n\nfunction _setFunc(word, len, curStart) {\n  var mask = (((1 << len) - 1) << curStart);\n  return word | mask;\n}\n\nfunction _unsetFunc(word, len, curStart) {\n  var mask = 0x7fffffff ^ (((1 << len) - 1) << curStart);\n  return word & mask;\n}\n\nfunction _and(word1, word2) {\n  return word1 & word2;\n}\n\nfunction _or(word1, word2) {\n  return word1 | word2;\n}\n\nfunction _xor(word1, word2) {\n  return word1 ^ word2;\n}\n\nif (typeof define === 'function' && define['amd']) {\n  define([], function () {\n    return BitSet;\n  });\n} else if (typeof exports === 'object') {\n  module['exports'] = BitSet;\n}\n","(function() {\n    function minRepr(str, comparer) {\n        let arr = str;\n        if (Array.isArray(str)) {\n            arr = str;\n        } else if (typeof(str) === 'string') {\n            arr = str.split('');\n        } else {\n            throw new Error('Parameter \"str\" should be a string or an array with comparable elements.');\n        }\n\n        const s = Array.prototype.concat(arr, arr);\n        if (comparer === undefined) {\n            comparer = function(a, b) {\n                if (a < b) {\n                    return -1;\n                } else if (a > b) {\n                    return 1;\n                } else {\n                    return 0;\n                }\n            };\n        }\n\n        let i = 0;\n        let j = 1;\n        const l = arr.length;\n        while (i < l && j < l) {\n            let k = 0;\n            while (comparer(s[i + k], s[j + k]) === 0 && k < l) {\n                ++k;\n            }\n            if (k === l) {\n                break;\n            }\n            if (comparer(s[i + k], s[j + k]) > 0) {\n                i = Math.max(i + k + 1, j + 1);\n            } else {\n                j = Math.max(j + k + 1, i + 1);\n            }\n        }\n\n        return Math.min(i, j);\n    }\n\n    module.exports = minRepr;\n})();","import ghops from 'graph-hops'\nimport Bitset from 'fast-bitset'\nimport minrepr from 'min-repr'\n\nexport function accidentals(size) {\n    let acc = new Bitset(size)\n    acc.set(0)\n    acc.set(1)\n    \n    let accidentals = []\n    for (let i=0; i<size; i++) {\n        accidentals.push(acc)\n        acc = acc.circularShift(1)\n    }\n\n    return accidentals;\n}\n\nexport function fromIndices(size,indices) {\n    let bs = new Bitset(size)\n    indices.forEach((x)=>{bs.set(x)})\n    return bs\n}\n\nexport function intervals(bs){\n    let r = []\n    let indices = bs.getIndices()\n    let size = indices.length\n    for(let i=0; i<size; i++){\n        r.push(indices[(i+1)%size] + (i+1 >= size ? bs.MAX_BIT+1 : 0) - indices[i])\n    }\n    return r;\n}\n\nexport function info(bs){\n    let sh = shape(bs,true)\n    sh['chroma'] = bs.getIndices()\n    let complement = bs.clone()\n    complement.toggleRange(0,complement.MAX_BIT);\n    sh['complement'] = complement.getIndices()\n    sh['id'] = String(sh['chroma'])\n    sh['bitset'] = bs\n    return sh\n}\n\nexport function shape(bs,info=false){\n    let intershape = intervals(bs)\n    let shift = minrepr(intershape)\n    let size = intershape.length\n    let shape = []\n    for(let i=shift; i<size+shift; i++){\n        shape.push(intershape[i%size])\n    }\n    shape = String(shape)\n    if(info){\n        return {intervals: intershape, shape: shape, offset: shift}\n    } else {\n        return shape\n    }\n}\n\n\nexport function findShapes(shapes,visit){\n    if(shapes.getIndices){shapes = [shapes]}\n    if(visit && visit.getIndices){visit = [visit]}\n    let size = shapes[0].MAX_BIT+1\n    visit = visit ? visit : shapes\n    shapes = shapes.map((s) => shape(s))\n    let lookingFor = (g) => shapes.includes(g['shape'])\n    let makeNode = info\n    let makeEdge = (f,t) => {return {from: f.id, to: t.id}} \n    return explore(visit,lookingFor,makeEdge,makeNode)\n}\n\nexport function explore(visit,lookingFor,makeEdge,makeNode){\n    makeEdge = makeEdge ? makeEdge : (frm,to) => ({from: frm, to: to})\n    makeNode = makeNode ? makeNode : (n) => n\n\n    lookingFor = lookingFor ? lookingFor : (g)=>true\n    if(visit && visit.getIndices){visit = [visit]}\n    let size = visit[0].MAX_BIT+1\n\n    let visited = []\n    let edges = []\n    let nodes = []\n\n    let Acc = accidentals(size)\n    while(visit.length > 0) {\n        let start = visit.pop()\n        let startNode = makeNode(start)\n        if (visited.includes(start.dehydrate())) { continue }\n        visited.push(start.dehydrate())\n        nodes.push(startNode)\n        let goto = Acc.map((a)=>start.xor(a))\n        for(let g of goto){\n            let gNode = makeNode(g)\n            if(lookingFor(gNode)){\n                edges.push(makeEdge(startNode,gNode))\n                if(!visited.includes(g.dehydrate())){\n                    visit.push(g)\n                }\n            }\n        }\n    }\n    return {nodes: nodes, edges: edges}\n}\n\n"],"names":["classCallCheck","instance","Constructor","TypeError","createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","defineProperty","key","protoProps","staticProps","prototype","FloydWarshall","adjacencyMatrix","_initializeDistanceMatrix","blankFiller","distMatrix","order","j","val","get$$1","k","direct","detour","Math","min","Infinity","dist","_i","_j","BITS_PER_INT","multiplyDeBruijnBitPosition","BitSet","nBitsOrKey","wordCount","arrVals","front","leadingZeros","ceil","arr","Uint32Array","MAX_BIT","JSON","parse","pop","set","get","idx","word","_getWord","setRange","from","to","_doRange","_setFunc","unset","unsetRange","_unsetFunc","toggle","toggleRange","_toggleFunc","clear","clone","dehydrate","lastUsedWord","s","and","bsOrIdx","_op","_and","or","_or","xor","_xor","forEach","func","ffs","nextSetBit","circularShift","offset","S","MASK_SIGN","BITS","WORDS","BITS_LAST_WORD","T","t","z","sourceWordLength","bits","bitsAdded","getCardinality","setCount","getIndices","indices","push","isSubsetOf","bs","arr1","arr2","len","isEmpty","isEqual","toString","str","fullString","slice","_startWord","setVal","fs","_lsb","ffz","fz","fls","ls","undefined","_msb","flz","wordIdx","unusedBitCount","startWord","mask","reducedWord","nextUnsetBit","previousSetBit","previousUnsetBit","curStart","curEnd","endWord","newBS","word1","word2","define","minRepr","comparer","Array","isArray","split","Error","concat","a","b","l","max","accidentals","size","acc","Bitset","fromIndices","x","intervals","r","info","sh","shape","complement","String","intershape","shift","minrepr","findShapes","shapes","visit","map","lookingFor","g","includes","makeNode","makeEdge","f","id","explore","frm","n","visited","edges","nodes","Acc","start","startNode","goto","gNode"],"mappings":"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"}